{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prism.Container.Extensions \u00b6 The Prism Container Extensions provide various additional extensions making the Prism Container easier to use with IServiceCollection/IServiceProvider and in scenarios where you may require a Singleton container that may need to be initialized from Platform specific code prior to PrismApplication being created. Note that both the Prism.Container.Extensions and Prism.DryIoc.Extensions are platform agnostic meaning you can use them on WPF or Xamarin Forms. Support \u00b6 This project is maintained by Dan Siegel. If this project or others maintained by Dan have helped you please help support the project by sponsoring Dan on GitHub! Why use the Container Extensions? \u00b6 While the Container abstractions provided by IContainerRegistry will give you what you need at least 95% of the time, there are still a number of times that you need to be able to do some more advanced registrations for your services. While adding these additional methods may confuse the average developer who is still struggling to understand \"What is a Transient, what is a Singleton, when do I use each?\". The extensions give you exactly what you need in order to write extremely loosely coupled code that can be reused from one project to another regardless of whether you are developing for Prism for WPF, Prism for Xamarin.Forms or just doing your own thing with Prism.Core. NuGet \u00b6 Package NuGet Sponsor Connect Prism.Container.Extensions Prism.Forms.Extended Prism.DryIoc.Extensions Prism.Microsoft.DependencyInjection.Extensions Prism.Unity.Extensions Shiny.Prism CI NuGet Feed \u00b6 Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed.","title":"Getting Started"},{"location":"#prismcontainerextensions","text":"The Prism Container Extensions provide various additional extensions making the Prism Container easier to use with IServiceCollection/IServiceProvider and in scenarios where you may require a Singleton container that may need to be initialized from Platform specific code prior to PrismApplication being created. Note that both the Prism.Container.Extensions and Prism.DryIoc.Extensions are platform agnostic meaning you can use them on WPF or Xamarin Forms.","title":"Prism.Container.Extensions"},{"location":"#support","text":"This project is maintained by Dan Siegel. If this project or others maintained by Dan have helped you please help support the project by sponsoring Dan on GitHub!","title":"Support"},{"location":"#why-use-the-container-extensions","text":"While the Container abstractions provided by IContainerRegistry will give you what you need at least 95% of the time, there are still a number of times that you need to be able to do some more advanced registrations for your services. While adding these additional methods may confuse the average developer who is still struggling to understand \"What is a Transient, what is a Singleton, when do I use each?\". The extensions give you exactly what you need in order to write extremely loosely coupled code that can be reused from one project to another regardless of whether you are developing for Prism for WPF, Prism for Xamarin.Forms or just doing your own thing with Prism.Core.","title":"Why use the Container Extensions?"},{"location":"#nuget","text":"Package NuGet Sponsor Connect Prism.Container.Extensions Prism.Forms.Extended Prism.DryIoc.Extensions Prism.Microsoft.DependencyInjection.Extensions Prism.Unity.Extensions Shiny.Prism","title":"NuGet"},{"location":"#ci-nuget-feed","text":"Want to consume the CI packages? Sign up as a GitHub sponsor and you can access the Sponsor Connect private feed.","title":"CI NuGet Feed"},{"location":"registerdelegates/","text":"Delegate Registration \u00b6 Sometimes you really need a bit more power behind constructing a service. For these times you may find yourself in one of the following scenarios: You just need to perform some Action like: public static IBackendService CreateBackendService () { return new BackendService { Uri = Constants . BackendUri }; } You need to resolve something to do a more complex look up and properly construct your type: public static IBackendService CreateBackendService ( IContainerProvider containerProvider ) { var options = containerProvider . Resolve < IOptions >(); return containerProvider . Resolve < IBackendService >(( typeof ( Uri ), options . BackendUri )); } Note This supports both Delegates with IContainerProvider and IServiceProvider Regardless of which way you need to resolve service the Delegate Registration extensions really help out for those scenarios where you can't just simply pass a raw implementing type. protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterDelegate < IFoo >( FooFactory ); containerRegistry . RegisterDelegate < IBar >( BarFactory ); } private static IFoo FooFactory () => new Foo (); private static IBar BarFactory ( IContainerProvider container ) { var options = container . Resolve < IOptions >(); return new Bar { HasCode = options . HasCode }; } private static IBar BarFactory ( IServiceProvider serviceProvider ) { var options = serviceProvider . GetService < IOptions >(); return new Bar { HasCode = options . HasCode }; }","title":"Delegate Registration"},{"location":"registerdelegates/#delegate-registration","text":"Sometimes you really need a bit more power behind constructing a service. For these times you may find yourself in one of the following scenarios: You just need to perform some Action like: public static IBackendService CreateBackendService () { return new BackendService { Uri = Constants . BackendUri }; } You need to resolve something to do a more complex look up and properly construct your type: public static IBackendService CreateBackendService ( IContainerProvider containerProvider ) { var options = containerProvider . Resolve < IOptions >(); return containerProvider . Resolve < IBackendService >(( typeof ( Uri ), options . BackendUri )); } Note This supports both Delegates with IContainerProvider and IServiceProvider Regardless of which way you need to resolve service the Delegate Registration extensions really help out for those scenarios where you can't just simply pass a raw implementing type. protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . RegisterDelegate < IFoo >( FooFactory ); containerRegistry . RegisterDelegate < IBar >( BarFactory ); } private static IFoo FooFactory () => new Foo (); private static IBar BarFactory ( IContainerProvider container ) { var options = container . Resolve < IOptions >(); return new Bar { HasCode = options . HasCode }; } private static IBar BarFactory ( IServiceProvider serviceProvider ) { var options = serviceProvider . GetService < IOptions >(); return new Bar { HasCode = options . HasCode }; }","title":"Delegate Registration"},{"location":"registermany/","text":"RegisterMany \u00b6 One of the very powerful new methods provided by the Container Extensions is the RegisterMany and RegisterManySingleton method. This really can help you reduce how much boilerplate code you need to write and provide some advanced scenarios. So what is it? public interface IFoo { void DoFoo (); } public interface IBar { void DoBar (); } To start let's assume that you have 2 interfaces like the ones above IFoo and IBar . Now let's assume that you have a single implementing type like: public class FooBar : IFoo , IBar { public void DoFoo () { Console . WriteLine ( \"Doing foo\" ); } public void DoBar () { Console . WriteLine ( \"Doing Bar\" ); } } Without the Container Extensions you might have a transient registration like: containerRegistry . Register < IFoo , FooBar >(); containerRegistry . Register < IBar , FooBar >(); While this may not be such a big deal, it suddenly starts making more sense when we expect the use of a singleton. The issue here is that if we were to do something similar to this to register a Singleton traditionally like: containerRegistry . RegisterSingleton < IFoo , FooBar >(); containerRegistry . RegisterSingleton < IBar , FooBar >(); We are under the impression that we have a singleton here. The issue of course is that if you check for equality like: if ( Container . Resolve < IFoo >() == Container . Resolve < IBar >()) { Console . WriteLine ( \"Foo and Bar are the same instance\" ); } else { Console . WriteLine ( \"Foo and Bar are difference instances\" ); } We might expect that the first case would evaluate to true that Foo and Bar are the same instance, but in reality they are two different instances. The issue isn't that we somehow didn't register them as a singleton because if you resolve IFoo twice and do the same equality check it will actually evaluate to true because they would be the same instance. However, Foo and Bar are different instances because they were registered separately. This is where RegisterManySingleton really shines. If we were to update our registration like: // Implicitly registers any implemented interfaces containerRegistry . RegisterManySingleton < FooBar >(); // Explicitly registers implemented interfaces containerRegistry . RegisterManySingleton < FooBar >( typeof ( IFoo ), typeof ( IBar )) We can now perform the same equality check above only this time IFoo and IBar would equal one another because they would both have been resolved from the same instance of the FooBar implementation.","title":"RegisterMany"},{"location":"registermany/#registermany","text":"One of the very powerful new methods provided by the Container Extensions is the RegisterMany and RegisterManySingleton method. This really can help you reduce how much boilerplate code you need to write and provide some advanced scenarios. So what is it? public interface IFoo { void DoFoo (); } public interface IBar { void DoBar (); } To start let's assume that you have 2 interfaces like the ones above IFoo and IBar . Now let's assume that you have a single implementing type like: public class FooBar : IFoo , IBar { public void DoFoo () { Console . WriteLine ( \"Doing foo\" ); } public void DoBar () { Console . WriteLine ( \"Doing Bar\" ); } } Without the Container Extensions you might have a transient registration like: containerRegistry . Register < IFoo , FooBar >(); containerRegistry . Register < IBar , FooBar >(); While this may not be such a big deal, it suddenly starts making more sense when we expect the use of a singleton. The issue here is that if we were to do something similar to this to register a Singleton traditionally like: containerRegistry . RegisterSingleton < IFoo , FooBar >(); containerRegistry . RegisterSingleton < IBar , FooBar >(); We are under the impression that we have a singleton here. The issue of course is that if you check for equality like: if ( Container . Resolve < IFoo >() == Container . Resolve < IBar >()) { Console . WriteLine ( \"Foo and Bar are the same instance\" ); } else { Console . WriteLine ( \"Foo and Bar are difference instances\" ); } We might expect that the first case would evaluate to true that Foo and Bar are the same instance, but in reality they are two different instances. The issue isn't that we somehow didn't register them as a singleton because if you resolve IFoo twice and do the same equality check it will actually evaluate to true because they would be the same instance. However, Foo and Bar are different instances because they were registered separately. This is where RegisterManySingleton really shines. If we were to update our registration like: // Implicitly registers any implemented interfaces containerRegistry . RegisterManySingleton < FooBar >(); // Explicitly registers implemented interfaces containerRegistry . RegisterManySingleton < FooBar >( typeof ( IFoo ), typeof ( IBar )) We can now perform the same equality check above only this time IFoo and IBar would equal one another because they would both have been resolved from the same instance of the FooBar implementation.","title":"RegisterMany"},{"location":"registerservices/","text":"Register Services \u00b6 For those coming from an ASP.NET Core background, you're already very familiar with the RegisterServices method in which we can add services to the IServiceCollection . In truth this doesn't make as much sense with Prism Applications to fully adopt this pattern. That said there are services which may already ship with Registration helpers for IServiceCollection . In these cases rather than making it more difficult on you, the PrismContainerExtensions aim to make your life a little easier by providing a simple extension method that will allow you to register certain services with the IServiceCollection which can then update the underlying container. Note For those using the Prism.Microsoft.DependencyInjection.Extensions package, the services are registered directly with the underlying IServiceCollection . PrismContainerExtension . Current . RegisterServices ( s => { s . AddHttpClient (); s . AddDbContext < AwesomeAppDbContext >( o => o . UseSqlite ( \"my connection string\" )); })","title":"Registration with IServiceCollection"},{"location":"registerservices/#register-services","text":"For those coming from an ASP.NET Core background, you're already very familiar with the RegisterServices method in which we can add services to the IServiceCollection . In truth this doesn't make as much sense with Prism Applications to fully adopt this pattern. That said there are services which may already ship with Registration helpers for IServiceCollection . In these cases rather than making it more difficult on you, the PrismContainerExtensions aim to make your life a little easier by providing a simple extension method that will allow you to register certain services with the IServiceCollection which can then update the underlying container. Note For those using the Prism.Microsoft.DependencyInjection.Extensions package, the services are registered directly with the underlying IServiceCollection . PrismContainerExtension . Current . RegisterServices ( s => { s . AddHttpClient (); s . AddDbContext < AwesomeAppDbContext >( o => o . UseSqlite ( \"my connection string\" )); })","title":"Register Services"},{"location":"scoping/","text":"Scoping \u00b6 TODO","title":"Scoped Services"},{"location":"scoping/#scoping","text":"TODO","title":"Scoping"},{"location":"containers/","text":"The Prism.Container.Extensions project currently has support for 3 third party Dependency Injection Containers: DryIoc Microsoft.Extensions.DependencyInjection Unity Container - (not to be confused with Unity Game Development...) Using the Containers \u00b6 All of the implementations follow some common practices for accessing the containers. Important There is absolutely ZERO that ties these container implementations to any platform. You can safely use them for WPF, Xamarin.Forms, or other platforms not officially supported by Prism. All examples shown here will be referencing the use for Xamarin applications. To access the container at any point you can access the current instance of the container from the Current property. Note that if no instance has been created yet, it will automatically initialize the container with our default configuration for the container. var container = PrismContainerExtension . Current ; // Creates a new instance with the default configuration var container = PrismContainerExtension . Create (); Warning Create should only ever be called a single time. For this reason if an instance has already been created, subsquent calls to Create will result in a NotSupportedException being thrown. Modifying PrismApplication \u00b6 When using the extended container extension you simply need to add the following to your PrismApplication to ensure that it uses the same instance that may have been created prior to the initialization of PrismApplication. protected override IContainerExtension CreateContainerExtension () => PrismContainerExtension . Current ; NOTE: This section ONLY applies to applications that are based on the Official packages from Prism. If you're using an Extended PrismApplication from this repo you should not modify the PrismApplication.","title":"Basics"},{"location":"containers/#using-the-containers","text":"All of the implementations follow some common practices for accessing the containers. Important There is absolutely ZERO that ties these container implementations to any platform. You can safely use them for WPF, Xamarin.Forms, or other platforms not officially supported by Prism. All examples shown here will be referencing the use for Xamarin applications. To access the container at any point you can access the current instance of the container from the Current property. Note that if no instance has been created yet, it will automatically initialize the container with our default configuration for the container. var container = PrismContainerExtension . Current ; // Creates a new instance with the default configuration var container = PrismContainerExtension . Create (); Warning Create should only ever be called a single time. For this reason if an instance has already been created, subsquent calls to Create will result in a NotSupportedException being thrown.","title":"Using the Containers"},{"location":"containers/#modifying-prismapplication","text":"When using the extended container extension you simply need to add the following to your PrismApplication to ensure that it uses the same instance that may have been created prior to the initialization of PrismApplication. protected override IContainerExtension CreateContainerExtension () => PrismContainerExtension . Current ; NOTE: This section ONLY applies to applications that are based on the Official packages from Prism. If you're using an Extended PrismApplication from this repo you should not modify the PrismApplication.","title":"Modifying PrismApplication"},{"location":"containers/dryioc/","text":"DryIoc is a fantastic container to use. It is extremely fast and performant and is the container that Dan recommends the most. Customizing the underlying container \u00b6 There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! var rules = Rules . Default . WithAutoConcreteTypeResolution () . With ( Made . Of ( FactoryMethod . ConstructorWithResolvableArguments )) . WithoutThrowOnRegisteringDisposableTransient () . WithFuncAndLazyWithoutRegistration () . WithDefaultIfAlreadyRegistered ( IfAlreadyRegistered . Replace ); // Option 1 PrismContainerExtension . Create ( rules ); // Option 2 var container = new Container ( rules ); PrismContainerExtension . Create ( container );","title":"DryIoc"},{"location":"containers/dryioc/#customizing-the-underlying-container","text":"There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! var rules = Rules . Default . WithAutoConcreteTypeResolution () . With ( Made . Of ( FactoryMethod . ConstructorWithResolvableArguments )) . WithoutThrowOnRegisteringDisposableTransient () . WithFuncAndLazyWithoutRegistration () . WithDefaultIfAlreadyRegistered ( IfAlreadyRegistered . Replace ); // Option 1 PrismContainerExtension . Create ( rules ); // Option 2 var container = new Container ( rules ); PrismContainerExtension . Create ( container );","title":"Customizing the underlying container"},{"location":"containers/microsoft-extensions-dependencyinjection/","text":"Microsoft.Extensions.DependencyInjection \u00b6 Warning!!! Support for this container is proof of concept. This may still have a number of bugs. It is not advised to use this for production code at this time. For a number of developers, the Service Provider in Microsoft.Extensions.DependencyInjection is a great lightweight D.I. container. Traditionally this has never been seriously considered for Prism support since Prism has a hard requirement on named services in order to resolve your Views. Prism also has a bit of a requirement that it be able to resolve a service that was never registered. What makes this different? \u00b6 The requirement for named services never went away, nor did the requirement that we can resolve types like your ViewModels which are never directly registered. This package provides some additions though that allow us to track mapping between keys and types as well as to resolve concrete types even if they haven't been registered. With these two enhancements built on top of Microsoft's DI Extensions we are able to support Prism with the container. Using the Container \u00b6 This container is most likely to be used any time that you're using Shiny, but this can be used completely independently from Shiny or even Prism. Customizing the underlying container \u00b6 There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! public void RegisterServices ( IServiceCollection services ) { // DO NOT DO THIS with Shiny.Prism!!! PrismContainerExtensions . Create ( services ); }","title":"Microsoft D.I. Extensions"},{"location":"containers/microsoft-extensions-dependencyinjection/#microsoftextensionsdependencyinjection","text":"Warning!!! Support for this container is proof of concept. This may still have a number of bugs. It is not advised to use this for production code at this time. For a number of developers, the Service Provider in Microsoft.Extensions.DependencyInjection is a great lightweight D.I. container. Traditionally this has never been seriously considered for Prism support since Prism has a hard requirement on named services in order to resolve your Views. Prism also has a bit of a requirement that it be able to resolve a service that was never registered.","title":"Microsoft.Extensions.DependencyInjection"},{"location":"containers/microsoft-extensions-dependencyinjection/#what-makes-this-different","text":"The requirement for named services never went away, nor did the requirement that we can resolve types like your ViewModels which are never directly registered. This package provides some additions though that allow us to track mapping between keys and types as well as to resolve concrete types even if they haven't been registered. With these two enhancements built on top of Microsoft's DI Extensions we are able to support Prism with the container.","title":"What makes this different?"},{"location":"containers/microsoft-extensions-dependencyinjection/#using-the-container","text":"This container is most likely to be used any time that you're using Shiny, but this can be used completely independently from Shiny or even Prism.","title":"Using the Container"},{"location":"containers/microsoft-extensions-dependencyinjection/#customizing-the-underlying-container","text":"There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! public void RegisterServices ( IServiceCollection services ) { // DO NOT DO THIS with Shiny.Prism!!! PrismContainerExtensions . Create ( services ); }","title":"Customizing the underlying container"},{"location":"containers/unity/","text":"Customizing the underlying container \u00b6 There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! var container = new UnityContainer (); PrismContainerExtension . Create ( container );","title":"Unity"},{"location":"containers/unity/#customizing-the-underlying-container","text":"There are times that you may want to customize some behavior of the container. For these times you may want to access one of the overload Create methods available. Note This is for ADVANCED USERS ONLY!!! If you do not know what you're doing with the D.I. container do not use these methods! var container = new UnityContainer (); PrismContainerExtension . Create ( container );","title":"Customizing the underlying container"},{"location":"forms/","text":"Using the Prism.Forms.Extended \u00b6 The Prism.Forms.Extended package is designed to make it even easier for you to integrate these fantastic packages. As you'll see using it is identical in every way to creating a typical Prism Application. The only difference is that you are installing the Prism.Forms.Extended package instead of Prism.Forms, Prism.DryIoc.Forms or Prism.Unity.Forms. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > </prism:PrismApplication> public partial class App { protected override void OnInitialized () { InitializeComponent (); NavigationService . NavigateAsync ( \"MainPage\" ); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // Register your services like normal containerRegistry . RegisterForNavigation < MainPage >(); } } Critical Notice The Prism Application in Prism.Forms.Extended requires the use of a container implementation from the Prism.Container.Extensions project. It will automatically wire in any reference without any changes to code. You simple need to ensure that Prism.DryIoc.Extensions, Prism.Microsoft.DependencyInjection.Extensions, or Prism.Unity.Extensions is installed. Why use Prism.Forms.Extended \u00b6 The extended PrismApplication is cross compiled for Xamarin.iOS and Xamarin.Android and provides several out of the box improvements over the normal PrismApplication. It provides you all of the container extensions found here that help make advanced registration scenarios much easier. It includes the ILogger from Prism.Plugin.Logging By default the AggregateLogger is registered and is available. It has pre-wired support for logging XAML errors and other issues directly from Xamarin.Forms (It will use your ILogger to log things like Bindings that cannot be resolved) Becase it is cross compiled, it has global Exception Handling built in for: Environment Platform AndroidEnvironment Android ObjectiveC.Runtime iOS AppDomain All TaskScheduler All Setting up the Aggregate Logger \u00b6 By default the AggregateLogger will have the ConsoleLogger added ensuring that any logging output will always be written to the Console. This is generally exactly what you want for development, and in Production this is often helpful as well as you can still view the log on your device with a build from the Google Play / App Store. Chances are though that you will want to add additional loggers. To do you this you will want to do the following: protected override void OnInitialized () { var logger = Container . Resolve < IAggregateLogger >(); // Add another logging implementation from the Logging Plugin // or that you have implemented logger . AddLogger ( Container . Resolve < SyslogLogger >()); }","title":"Intro"},{"location":"forms/#using-the-prismformsextended","text":"The Prism.Forms.Extended package is designed to make it even easier for you to integrate these fantastic packages. As you'll see using it is identical in every way to creating a typical Prism Application. The only difference is that you are installing the Prism.Forms.Extended package instead of Prism.Forms, Prism.DryIoc.Forms or Prism.Unity.Forms. <prism:PrismApplication xmlns= \"http://xamarin.com/schemas/2014/forms\" xmlns:x= \"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:prism= \"http://prismlibrary.com\" x:Class= \"Contoso.Awesome.App\" > </prism:PrismApplication> public partial class App { protected override void OnInitialized () { InitializeComponent (); NavigationService . NavigateAsync ( \"MainPage\" ); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { // Register your services like normal containerRegistry . RegisterForNavigation < MainPage >(); } } Critical Notice The Prism Application in Prism.Forms.Extended requires the use of a container implementation from the Prism.Container.Extensions project. It will automatically wire in any reference without any changes to code. You simple need to ensure that Prism.DryIoc.Extensions, Prism.Microsoft.DependencyInjection.Extensions, or Prism.Unity.Extensions is installed.","title":"Using the Prism.Forms.Extended"},{"location":"forms/#why-use-prismformsextended","text":"The extended PrismApplication is cross compiled for Xamarin.iOS and Xamarin.Android and provides several out of the box improvements over the normal PrismApplication. It provides you all of the container extensions found here that help make advanced registration scenarios much easier. It includes the ILogger from Prism.Plugin.Logging By default the AggregateLogger is registered and is available. It has pre-wired support for logging XAML errors and other issues directly from Xamarin.Forms (It will use your ILogger to log things like Bindings that cannot be resolved) Becase it is cross compiled, it has global Exception Handling built in for: Environment Platform AndroidEnvironment Android ObjectiveC.Runtime iOS AppDomain All TaskScheduler All","title":"Why use Prism.Forms.Extended"},{"location":"forms/#setting-up-the-aggregate-logger","text":"By default the AggregateLogger will have the ConsoleLogger added ensuring that any logging output will always be written to the Console. This is generally exactly what you want for development, and in Production this is often helpful as well as you can still view the log on your device with a build from the Google Play / App Store. Chances are though that you will want to add additional loggers. To do you this you will want to do the following: protected override void OnInitialized () { var logger = Container . Resolve < IAggregateLogger >(); // Add another logging implementation from the Logging Plugin // or that you have implemented logger . AddLogger ( Container . Resolve < SyslogLogger >()); }","title":"Setting up the Aggregate Logger"},{"location":"forms/executionawarecommand/","text":"Have you ever looked at ReactiveCommand and wished that the DelegateCommand could be more like that, while also wishing the ReactiveCommand could be more like the DelegateCommand. This was the reason that yet another command was introduced in the Prism.Forms.Extended package. The ExecutionAwareCommand solves a few problems. Fluent API Support for Async Delegates Support for ObservesProperty Support for ObservesCanExecute Support for adding Exception Handlers directly on the Command Support for adding a IsExecuting Changed delegate Support for opting in or out of InvalidCastExceptions Using the ExecutionAwareCommand \u00b6 public class ViewAViewModel : BindableBase { public ViewAViewModel () { FooCommand = ExecutionAwareCommand . FromAction ( DoFoo ) . OnIsExecutingChanged ( b => IsBusy = b ) . Catch ( e => { // equivalent to catch(Exception e) }) . Catch < NullReferenceException >( e => { // e is strongly typed as NullReferenceException }); } private bool _isBusy ; public bool IsBusy { get => _isBusy ; set => SetProperty ( ref _isBusy , value ); } public ICommand FooCommand { get ; } private void DoFoo () { // Do Foo } } Note Both ExecutionAwareCommand and ExecutionAwareCommand<T> only support creation from the factory methods: FromAction FromTask","title":"ExecutionAwareCommand"},{"location":"forms/executionawarecommand/#using-the-executionawarecommand","text":"public class ViewAViewModel : BindableBase { public ViewAViewModel () { FooCommand = ExecutionAwareCommand . FromAction ( DoFoo ) . OnIsExecutingChanged ( b => IsBusy = b ) . Catch ( e => { // equivalent to catch(Exception e) }) . Catch < NullReferenceException >( e => { // e is strongly typed as NullReferenceException }); } private bool _isBusy ; public bool IsBusy { get => _isBusy ; set => SetProperty ( ref _isBusy , value ); } public ICommand FooCommand { get ; } private void DoFoo () { // Do Foo } } Note Both ExecutionAwareCommand and ExecutionAwareCommand<T> only support creation from the factory methods: FromAction FromTask","title":"Using the ExecutionAwareCommand"},{"location":"forms/fluent-navigation/","text":"The use of fluent API's and declartive syntax is gaining popularity. There is a lot to be said for this as it becomes very clear about what we might expect. Using the Fluent API \u00b6 navService . Navigate ( \"ViewA\" ) . WithParameter ( \"message\" , \"Hello World\" ) . Catch ( e => { // Equivalent to catch(Exception e) }) . Catch < ArgumentNullException >( e => { // Equivalent to catch(ArgumentNullException e) }) . ExecuteAsync (); Note When using the Fluent API, ExecuteAsync returns a Task<bool> and not a Task<INavigationResult> . It is important that if you want to do something with an exception returned by the INavigationResult in the underlying API, you must provide a Catch to handle it in the Fluent API.","title":"Fluent Navigation"},{"location":"forms/fluent-navigation/#using-the-fluent-api","text":"navService . Navigate ( \"ViewA\" ) . WithParameter ( \"message\" , \"Hello World\" ) . Catch ( e => { // Equivalent to catch(Exception e) }) . Catch < ArgumentNullException >( e => { // Equivalent to catch(ArgumentNullException e) }) . ExecuteAsync (); Note When using the Fluent API, ExecuteAsync returns a Task<bool> and not a Task<INavigationResult> . It is important that if you want to do something with an exception returned by the INavigationResult in the underlying API, you must provide a Catch to handle it in the Fluent API.","title":"Using the Fluent API"},{"location":"forms/navigationerrors/","text":"Errors happen when navigating. Using the PrismApplication in Prism.Forms.Extended allows you to automatically and globally handle these errors. Default Behavior \u00b6 Writes to the Console that there was a Navigation Error Resolves the ILogger, and Reports the Error with the following additional properties Serializes the NavigationParameters to a JSON string Adds the Navigation Uri Overriding the Default Behavior \u00b6 If the output on the NavigationError isn't quite what you're hoping for you will need to override the OnNavigationError in PrismApplication . As an example below we will maintain the same logging behavior but ensure that while debugging we always hit a breakpoint so we can explore the values of the Navigation Error anytime this is encountered. protected override void OnNavigationError ( INavigationError navigationError ) { #if DEBUG // Ensure we always break here while debugging! System . Diagnostics . Debugger . Break (); #endif base . OnNavigationError ( navigationError ); }","title":"Global Navigation Errors"},{"location":"forms/navigationerrors/#default-behavior","text":"Writes to the Console that there was a Navigation Error Resolves the ILogger, and Reports the Error with the following additional properties Serializes the NavigationParameters to a JSON string Adds the Navigation Uri","title":"Default Behavior"},{"location":"forms/navigationerrors/#overriding-the-default-behavior","text":"If the output on the NavigationError isn't quite what you're hoping for you will need to override the OnNavigationError in PrismApplication . As an example below we will maintain the same logging behavior but ensure that while debugging we always hit a breakpoint so we can explore the values of the Navigation Error anytime this is encountered. protected override void OnNavigationError ( INavigationError navigationError ) { #if DEBUG // Ensure we always break here while debugging! System . Diagnostics . Debugger . Break (); #endif base . OnNavigationError ( navigationError ); }","title":"Overriding the Default Behavior"},{"location":"forms/pagebehaviorfactory/","text":"Prism's IPageBehaviorFactory is a great way to apply some custom behaviors on to pages either globally or with a little business logic. The Extended Prism.Forms package uses a custom PageBehaviorFactory. In addition to the normal behaviors that Prism applies to your Pages behind the scenes, the Extended version provides support for the following: Globally adding Platform Specifics on: SetToolbarPlacement on Android TabbedPage Use Safe Area on iOS PreferLargeTitles on iOS A custom behavior that changes the Title of a TabbedPage to always match the actively selected Tab To control these features you simply need to register an implementation of IPageBehaviorFactoryOptions . Note A default instance is provided automatically that enables all of these features. internal class MyPageBehaviorFactoryOptions : IPageBehaviorFactoryOptions { public bool UseBottomTabs => true ; public bool UseSafeArea => true ; public bool UseChildTitle => true ; public bool PreferLargeTitles => true ; } Using Explicit Values \u00b6 While it's great to generalize certain Platform Specifics like UseBottomTabs or UseSafeArea , there may be times which you prefer to opt-out of these platform specifics from the PageBehaviorFactory and either use the default value or a custom value. For these times you can update your XAML as follows: <ContentPage xmlns:prism= \"http://prismlibrary.com\" prism:PlatformSpecifics.UseExplicit= \"true\" > Or in Code: public class ViewA : ContentPage { public ViewA () { PlatformSpecifics . SetUseExplicit ( this , true ); } }","title":"Page Behavior Factory"},{"location":"forms/pagebehaviorfactory/#using-explicit-values","text":"While it's great to generalize certain Platform Specifics like UseBottomTabs or UseSafeArea , there may be times which you prefer to opt-out of these platform specifics from the PageBehaviorFactory and either use the default value or a custom value. For these times you can update your XAML as follows: <ContentPage xmlns:prism= \"http://prismlibrary.com\" prism:PlatformSpecifics.UseExplicit= \"true\" > Or in Code: public class ViewA : ContentPage { public ViewA () { PlatformSpecifics . SetUseExplicit ( this , true ); } }","title":"Using Explicit Values"},{"location":"shiny/","text":"Working With Shiny \u00b6 Shiny uses the Microsoft.Extensions.DependencyInjection pattern of service registration found in ASP.NET Core applications with a Startup class. This in particular is a use case in which you will need to initialize a container prior to Forms.Init being called on the native platform. To work with Shiny you simply need to do something like the following: // Android [Application] public class App : Android . App . Application { public override void OnCreate () { AndroidShinyHost . Init ( this , new MyStartup ()); } } // iOS [Register(\"AppDelegate\")] public partial class AppDelegate : FormsApplicationDelegate { public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { // this needs to be loaded before EVERYTHING iOSShinyHost . Init ( new MyStartup ()); Forms . Init (); this . LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } // if you are using jobs, you need this public override void PerformFetch ( UIApplication application , Action < UIBackgroundFetchResult > completionHandler ) => JobManager . OnBackgroundFetch ( completionHandler ); }","title":"Intro"},{"location":"shiny/#working-with-shiny","text":"Shiny uses the Microsoft.Extensions.DependencyInjection pattern of service registration found in ASP.NET Core applications with a Startup class. This in particular is a use case in which you will need to initialize a container prior to Forms.Init being called on the native platform. To work with Shiny you simply need to do something like the following: // Android [Application] public class App : Android . App . Application { public override void OnCreate () { AndroidShinyHost . Init ( this , new MyStartup ()); } } // iOS [Register(\"AppDelegate\")] public partial class AppDelegate : FormsApplicationDelegate { public override bool FinishedLaunching ( UIApplication app , NSDictionary options ) { // this needs to be loaded before EVERYTHING iOSShinyHost . Init ( new MyStartup ()); Forms . Init (); this . LoadApplication ( new App ()); return base . FinishedLaunching ( app , options ); } // if you are using jobs, you need this public override void PerformFetch ( UIApplication application , Action < UIBackgroundFetchResult > completionHandler ) => JobManager . OnBackgroundFetch ( completionHandler ); }","title":"Working With Shiny"},{"location":"shiny/modularity/","text":"Modularity support for Shiny is a preview feature and can be used by overriding the ConfigureModuleCatalog method in the PrismStartup , and adding modules just as you would do in the PrismApplication. Why on earth would I use this \u00b6 Ok it's a fair question why should you use this? Let's say that you are trying to build out a Modular application with Prism, but you also need some things from Shiny like you need to register some sort of Background Service. Rather than push the buck to the consuming application to wire everything up this can be taken of in the Module which can now be reused across apps with a more minimalistic configuration. How to use Modules with Shiny and Prism \u00b6 public class AppStartup : PrismStartup { public MockModuleStartup ( ITestOutputHelper testOutputHelper ) : base ( testOutputHelper ) { } protected override void ConfigureServices ( IServiceCollection services ) { // Register your services here... } protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < MyShinyModule >(); } } Note If adding modules here do not add the same module in your PrismApplication! Creating a Shiny Module \u00b6 Ok as if Modularity wasn't confusing enough... now we had to go and add a Shiny Module... The Shiny Module lets us continue to work with the ServiceCollection that you may have started with in the Startup class. As you'll see by inheriting from ShinyModule or StartupModule we can add services that we may need to here. public class MyShinyModule : ShinyModule { protected override void ConfigureServices ( IServiceCollection services ) { services . AddTransient < IMockModuleServiceA , MockModuleServiceA >(); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . Register < IMockModuleServiceB , MockModuleServiceB >(); } } Critical Note Depending on what you are registering you may need to use a StartupModule which forces the registration to be actually at Startup.","title":"Modularity"},{"location":"shiny/modularity/#why-on-earth-would-i-use-this","text":"Ok it's a fair question why should you use this? Let's say that you are trying to build out a Modular application with Prism, but you also need some things from Shiny like you need to register some sort of Background Service. Rather than push the buck to the consuming application to wire everything up this can be taken of in the Module which can now be reused across apps with a more minimalistic configuration.","title":"Why on earth would I use this"},{"location":"shiny/modularity/#how-to-use-modules-with-shiny-and-prism","text":"public class AppStartup : PrismStartup { public MockModuleStartup ( ITestOutputHelper testOutputHelper ) : base ( testOutputHelper ) { } protected override void ConfigureServices ( IServiceCollection services ) { // Register your services here... } protected override void ConfigureModuleCatalog ( IModuleCatalog moduleCatalog ) { moduleCatalog . AddModule < MyShinyModule >(); } } Note If adding modules here do not add the same module in your PrismApplication!","title":"How to use Modules with Shiny and Prism"},{"location":"shiny/modularity/#creating-a-shiny-module","text":"Ok as if Modularity wasn't confusing enough... now we had to go and add a Shiny Module... The Shiny Module lets us continue to work with the ServiceCollection that you may have started with in the Startup class. As you'll see by inheriting from ShinyModule or StartupModule we can add services that we may need to here. public class MyShinyModule : ShinyModule { protected override void ConfigureServices ( IServiceCollection services ) { services . AddTransient < IMockModuleServiceA , MockModuleServiceA >(); } protected override void RegisterTypes ( IContainerRegistry containerRegistry ) { containerRegistry . Register < IMockModuleServiceB , MockModuleServiceB >(); } } Critical Note Depending on what you are registering you may need to use a StartupModule which forces the registration to be actually at Startup.","title":"Creating a Shiny Module"},{"location":"shiny/navigation/","text":"Navigation from Shiny Services \u00b6 While this is generally not a great idea, there could potentially be times in which you need to navigate from a background service. For these times you will need to use the INavigationServiceDelegate. It is important to understand that the NavigationServiceDelegate differs from the NavigationService that you are used to using as it will attempt to determine what the currently displayed page is and Navigate from there. This will do exactly what you want if you are resetting the NavigationStack but may not work as expected if you are doing some sort of relative navigation. public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { services . UseNavigationDelegate (); } } public class NotificationDelegate : INotificationDelegate { private INavigationServiceDelegate NavigationService { get ; } public NotificationDelegate ( INavigationServiceDelegate navigationServiceDelegate ) { NavigationService = navigationServiceDelegate ; } public async Task OnEntry ( NotificationResponse response ) { if (! string . IsNullOrEmpty ( notification . Payload )) { await NavigationService . NavigateAsync ( notification . Payload ); } } public Task OnReceived ( Notification notification ) { if (! string . IsNullOrEmpty ( notification . Payload )) { await NavigationService . NavigateAsync ( notification . Payload ); } } }","title":"Navigation"},{"location":"shiny/navigation/#navigation-from-shiny-services","text":"While this is generally not a great idea, there could potentially be times in which you need to navigate from a background service. For these times you will need to use the INavigationServiceDelegate. It is important to understand that the NavigationServiceDelegate differs from the NavigationService that you are used to using as it will attempt to determine what the currently displayed page is and Navigate from there. This will do exactly what you want if you are resetting the NavigationStack but may not work as expected if you are doing some sort of relative navigation. public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { services . UseNavigationDelegate (); } } public class NotificationDelegate : INotificationDelegate { private INavigationServiceDelegate NavigationService { get ; } public NotificationDelegate ( INavigationServiceDelegate navigationServiceDelegate ) { NavigationService = navigationServiceDelegate ; } public async Task OnEntry ( NotificationResponse response ) { if (! string . IsNullOrEmpty ( notification . Payload )) { await NavigationService . NavigateAsync ( notification . Payload ); } } public Task OnReceived ( Notification notification ) { if (! string . IsNullOrEmpty ( notification . Payload )) { await NavigationService . NavigateAsync ( notification . Payload ); } } }","title":"Navigation from Shiny Services"},{"location":"shiny/startup/","text":"public class PrismStartup : ShinyStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGpsBackground < MyDelegate >(); } public override IServiceProvider CreateServiceProvider ( IServiceCollection services ) { return PrismContainerExtension . Current . CreateServiceProvider ( services ); } } Shiny.Prism \u00b6 With your App using the PrismApplication from Prism.DryIoc.Forms.Extended you now only need to reference the PrismStartup as the base class for your Startup class like: public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGps < MyDelegate >(); } } You can now pass your startup to the ShinyHost at your application's startup and use full Dependency Injection of Shiny's services in your app, full DI of services from Prism's container within services that are resolved by Shiny. NOTE: Shiny uses IServiceProvider which does not support the use of named services.","title":"Startup"},{"location":"shiny/startup/#shinyprism","text":"With your App using the PrismApplication from Prism.DryIoc.Forms.Extended you now only need to reference the PrismStartup as the base class for your Startup class like: public class MyStartup : PrismStartup { public override void ConfigureServices ( IServiceCollection services ) { // Register services with Shiny like: services . UseGps < MyDelegate >(); } } You can now pass your startup to the ShinyHost at your application's startup and use full Dependency Injection of Shiny's services in your app, full DI of services from Prism's container within services that are resolved by Shiny. NOTE: Shiny uses IServiceProvider which does not support the use of named services.","title":"Shiny.Prism"}]}